# JavaMarketCheckout

## 设计模式——策略模式

1. 策略模式的定义
   - 策略模式（Strategy Pattern）是一种行为设计模式。它定义了一系列算法，将每个算法封装起来，并使它们可以相互替换。策略模式让算法的变化独立于使用算法的客户。
   - 简单来说，就像是有多种解决问题的策略，并且可以根据不同的情况灵活地选择和切换这些策略。
2. 策略模式的结构
   - **策略接口（Strategy Interface）**：这是所有具体策略类都要实现的接口，它定义了算法的方法签名。例如，在一个简单的计算折扣的场景中，策略接口可以是`DiscountStrategy`，其中包含一个`calculateDiscount()`方法。
   - **具体策略类（Concrete Strategy Classes）**：这些类实现了策略接口，提供了具体的算法实现。比如，有`StudentDiscountStrategy`类实现了`DiscountStrategy`接口，在`calculateDiscount()`方法中提供了学生折扣的计算逻辑，如打八折；还有`VIPDiscountStrategy`类提供了 VIP 客户的折扣计算逻辑，如打七折。
   - **上下文类（Context Class）**：上下文类持有一个策略接口的引用，它可以在运行时根据需要选择和调用具体的策略。继续以折扣计算为例，`ShoppingCart`类可以作为上下文类，它内部有一个`DiscountStrategy`类型的成员变量。`ShoppingCart`类的`calculateTotal()`方法可以根据当前设置的折扣策略来计算购物车商品的总价。
3. 策略模式的工作原理
   - 当需要执行一个算法时，客户端（可以是另一个对象或者用户操作）通过上下文类来调用策略接口的方法。上下文类负责选择具体的策略对象来执行算法。
   - 例如，在一个电商系统中，用户在结算购物车商品时，系统会根据用户的身份（是学生、VIP 还是普通用户）来选择不同的折扣策略。如果用户是学生，上下文类就会使用`StudentDiscountStrategy`来计算折扣后的总价；如果是 VIP 用户，就会使用`VIPDiscountStrategy`。
4. 策略模式的优点
   - **可扩展性好**：如果需要添加新的策略，只需要实现策略接口，然后在上下文类中能够选择使用这个新策略即可。例如，添加一个`SeniorCitizenDiscountStrategy`来为老年用户提供折扣，只需要创建这个新类并实现`DiscountStrategy`接口，然后在购物车的结算逻辑中（上下文类）考虑如何选择使用这个新策略。
   - **可维护性高**：每个策略的实现都在独立的类中，代码结构清晰。如果某个策略的算法需要修改，只需要修改对应的策略类，不会影响到其他部分的代码。比如，如果学生折扣的计算规则发生变化，只需要修改`StudentDiscountStrategy`类中的`calculateDiscount()`方法。
   - **灵活性强**：可以在运行时动态地切换策略。例如，在购物车结算过程中，用户可以选择使用哪种折扣方式（如果系统允许），通过改变上下文类中引用的策略对象来实现不同的折扣计算。
5. 策略模式的缺点
   - **策略类数量可能过多**：如果有很多种策略，会导致策略类的数量增加，使得代码的复杂性在一定程度上提高。例如，一个系统中有几十种不同的用户折扣策略，就会有几十种策略类，管理这些类可能会变得比较繁琐。
   - **客户端需要了解策略差异**：客户端（使用策略的对象）需要知道不同策略之间的区别，以便能够正确地选择策略。在复杂的场景下，这可能会增加客户端的负担。例如，如果购物系统中有很多种复杂的折扣策略，用户（客户端）可能会很难理解每种策略的具体适用情况。
6. 策略模式的应用场景
   - **算法替换场景**：当一个系统中有多种算法可以完成同一种任务，并且这些算法可能会经常变化时，适合使用策略模式。例如，在一个图形绘制系统中，有多种绘制图形的算法，如简单绘制、抗锯齿绘制等，可以将这些算法封装成不同的策略，根据用户的选择或者系统的要求来使用不同的绘制策略。
   - **游戏开发中的 AI 行为决策**：在游戏中，非玩家角色（NPC）的行为可以有多种策略。比如，在一个角色扮演游戏中，敌人的攻击策略可以有近战攻击、远程攻击等多种策略。这些策略可以根据敌人的类型、玩家的位置等因素动态切换，使用策略模式可以很好地实现这种行为决策机制。