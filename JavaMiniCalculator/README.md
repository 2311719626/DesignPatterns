# JavaMiniCalculator

## 设计模式——工厂模式

1. **工厂模式的定义**
   - 工厂模式（Factory Pattern）是一种创建对象的设计模式。它提供了一种创建对象的方式，将对象的创建和使用分离，使得代码在创建对象时更加灵活和可维护。

2. **简单工厂模式（Simple Factory Pattern）**
   - **结构**：
     - **产品接口（Product Interface）**：定义了产品的公共行为和属性。例如，在一个图形绘制程序中，`Shape`接口可以定义`draw()`方法，这是所有图形都要具备的绘制方法。
     - **具体产品类（Concrete Product Classes）**：实现了产品接口，提供了具体的产品实现。比如，`Circle`类、`Rectangle`类和`Triangle`类都实现了`Shape`接口，它们分别提供了绘制圆形、矩形和三角形的具体实现。
     - **工厂类（Factory Class）**：负责创建产品对象。例如，`ShapeFactory`类有一个方法（如`createShape(String shapeType)`），根据传入的类型参数（如“circle”、“rectangle”或“triangle”）来创建相应的形状对象。
   - **工作原理**：
     - 当客户端需要一个产品对象时，它调用工厂类的创建方法，传入相应的参数。工厂类根据参数来判断应该创建哪种具体的产品对象，然后返回该对象给客户端。例如，客户端代码`Shape shape = ShapeFactory.createShape("circle");`会调用工厂类的方法创建一个圆形对象。
   - **优点**：
     - **解耦对象创建和使用**：客户端不需要知道具体产品对象是如何创建的，只需要知道通过工厂类可以获取到所需的产品。这样可以降低客户端代码和产品创建代码之间的耦合度。例如，在一个复杂的软件系统中，多个模块可能都需要使用图形对象，使用工厂模式可以将图形对象的创建集中在工厂类中，其他模块只需要从工厂获取即可。
     - **便于代码维护和扩展**：如果要添加新的产品，只需要在工厂类中添加创建新产品的逻辑，并创建新的具体产品类实现产品接口。例如，要添加一个新的图形“Square”，只需要创建`Square`类实现`Shape`接口，然后在`ShapeFactory`类中添加创建方形对象的逻辑。
   - **缺点**：
     - **不符合开闭原则（对扩展开放，对修改关闭）**：每当添加新的产品时，都需要修改工厂类的代码。例如，在`ShapeFactory`类中添加创建方形对象的逻辑时，需要修改`createShape`方法，这在一定程度上违反了开闭原则。
     - **工厂类职责过重**：所有产品的创建逻辑都集中在工厂类中，如果产品种类很多，工厂类会变得很复杂。例如，如果有几十种不同的图形需要创建，`ShapeFactory`类的`createShape`方法可能会变得非常庞大和复杂。

3. **工厂方法模式（Factory Method Pattern）**
   - **结构**：
     - **产品接口（Product Interface）**：和简单工厂模式一样，定义产品的公共行为和属性。
     - **具体产品类（Concrete Product Classes）**：也是实现产品接口，提供具体产品实现。
     - **抽象工厂类（Abstract Factory Class）**：包含一个抽象的创建方法，用于创建产品对象。例如，`ShapeFactory`抽象类有一个抽象方法`createShape()`。
     - **具体工厂类（Concrete Factory Classes）**：继承自抽象工厂类，实现抽象的创建方法，用于创建特定类型的产品。比如，`CircleFactory`类继承自`ShapeFactory`，它实现`createShape()`方法来创建圆形对象。
   - **工作原理**：
     - 客户端通过调用具体工厂类的创建方法来获取产品对象。例如，`Shape circle = new CircleFactory().createShape();`，这样可以得到一个圆形对象。不同的具体工厂类负责创建不同类型的产品。
   - **优点**：
     - **符合开闭原则**：当添加新的产品时，只需要创建新的具体工厂类和具体产品类，不需要修改现有的工厂类。例如，添加方形产品时，创建`SquareFactory`和`Square`类，不需要修改其他工厂类的代码。
     - **代码结构更清晰**：每个具体工厂类只负责创建一种产品，职责更加明确。相比简单工厂模式，工厂方法模式的代码结构在产品种类较多时更易于管理。
   - **缺点**：
     - **工厂类数量增加**：每增加一种产品，就需要创建一个新的具体工厂类。如果产品种类很多，会导致工厂类的数量也很多，增加了代码的复杂性。例如，有很多种不同的图形，就会有很多对应的工厂类。
     - **客户端需要知道具体工厂类**：客户端需要知道使用哪个具体工厂类来获取所需的产品，这增加了客户端的负担。例如，客户端要获取圆形对象，需要知道使用`CircleFactory`类。

4. **抽象工厂模式（Abstract Factory Pattern）**
   - **结构**：
     - **抽象产品族接口（Abstract Product Family Interfaces）**：定义了一组相关产品的接口。例如，在一个游戏开发场景中，`GUIFactory`抽象接口可以定义创建游戏菜单（`Menu`接口）和游戏按钮（`Button`接口）的方法。
     - **具体产品族类（Concrete Product Family Classes）**：实现了抽象产品族接口，提供了一组相关产品的具体实现。比如，`WindowsGUIFactory`类实现`GUIFactory`接口，它可以创建Windows风格的菜单和按钮；`MacGUIFactory`类可以创建Mac风格的菜单和按钮。
     - **抽象工厂类（Abstract Factory Class）**：包含抽象的创建产品族的方法。例如，`AbstractGameFactory`抽象类有抽象方法用于创建游戏的图形界面（`createGUIFactory()`）和游戏角色（`createCharacterFactory()`）等。
     - **具体工厂类（Concrete Factory Classes）**：继承自抽象工厂类，实现抽象的创建产品族的方法。例如，`WindowsGameFactory`类继承自`AbstractGameFactory`，它实现创建Windows风格游戏图形界面和角色的方法。
   - **工作原理**：
     - 客户端通过调用具体工厂类的方法来获取一组相关的产品。例如，`AbstractGameFactory factory = new WindowsGameFactory();`，然后可以使用`factory.createGUIFactory()`获取Windows风格的图形界面产品族。
   - **优点**：
     - **代码的灵活性和可维护性高**：可以很方便地切换产品族，并且产品族内的产品创建逻辑是封装在一起的。例如，在游戏开发中，可以很容易地从Windows风格的游戏界面和角色切换到Mac风格的，只需要使用不同的具体工厂类。
     - **便于产品的一致性维护**：因为是按照产品族来创建产品，所以可以保证同一产品族内的产品在风格、交互方式等方面的一致性。例如，Windows风格的菜单和按钮在外观和操作方式上会保持一致。
   - **缺点**：
     - **代码复杂度高**：抽象工厂模式的结构比较复杂，涉及到多个抽象类、接口和具体类。对于简单的场景，可能会显得过于复杂。例如，在一个小型应用中，可能不需要这么复杂的对象创建机制。
     - **不易扩展**：添加新的产品族或者产品比较复杂，需要修改多个类的代码。例如，要添加一个新的Linux风格的游戏产品族，需要创建多个新的类并且修改抽象工厂类和相关的接口。
